<!doctype html>
<html lang="en" class="no-js">
	<script>document.documentElement.classList.remove('no-js');</script>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
		<title>Meet in Space: Video Conferencing in Spatial Audio</title>
		<meta name="description" content="Teleconferencing in spatial audio with the help of Jitsi Meet and Web Audio">
		<meta name="generator" content="Eleventy v3.0.0">

		
		<link rel="icon" href="icon/favicons/favicon.ico" sizes="32x32">
		<link rel="icon" href="icon/favicons/icon.svg" type="image/svg+xml">
		<link rel="apple-touch-icon" href="icon/favicons/apple-touch-icon.png">
		<link rel="manifest" href="icon/favicons/manifest.webmanifest">

		<link rel="preload" as="font" href="/font/Switzer-Variable.subset.woff2" crossorigin>
		<link rel="preload" as="font" href="/font/Rag-Regular.subset.woff2" crossorigin>
		<link rel="alternate" href="/feed/feed.xml" type="application/atom+xml" title="Jackson">
		<link rel="alternate" href="/feed/feed.json" type="application/json" title="Jackson">
		<style>
			/*
  Josh's Custom CSS Reset
  https://www.joshwcomeau.com/css/custom-css-reset/
*/
*,
*::before,
*::after {
	box-sizing: border-box;
}
* {
	line-height: calc(1em + 0.725rem);
	margin: 0;
}
body {
	-webkit-font-smoothing: antialiased;
}
img,
picture,
video,
canvas,
svg {
	display: block;
	max-width: 100%;
}
input,
button,
textarea,
select {
	font: inherit;
}
p,
h1,
h2,
h3,
h4,
h5,
h6 {
	overflow-wrap: break-word;
	margin: revert;
}
#root,
#__next {
	isolation: isolate;
}

		:root {
	--color-bg: white;
	--color-gray-20: #333333;
	--color-gray-50: #7f7f7f;
	--color-gray-90: #e5e5e5;
	--font-family: "Rag", -apple-system, system-ui, sans-serif;
	--font-family-monospace: Consolas, Menlo, Monaco, Andale Mono WT, Andale Mono,
		Lucida Console, Lucida Sans Typewriter, DejaVu Sans Mono,
		Bitstream Vera Sans Mono, Liberation Mono, Nimbus Mono L, Courier New,
		Courier, monospace;
	--syntax-tab-size: 2;
	--noise-img: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 600 600'%3E%3Cfilter id='a'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='.65' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23a)'/%3E%3C/svg%3E");
	--noise-opacity: 0.2;
	/* Josh Comeau shadows */
	--shadow-color: 0deg 0% 0%;
	--shadow-elevation-low: 0px 0.2px 0.2px hsl(var(--shadow-color) / 0.16),
		0.1px 0.8px 0.8px -3px hsl(var(--shadow-color) / 0.13);
	--shadow-elevation-medium: 0px 0.2px 0.2px hsl(var(--shadow-color) / 0.15),
		0.1px 1px 1.1px -1.5px hsl(var(--shadow-color) / 0.13),
		0.3px 4.2px 4.4px -3px hsl(var(--shadow-color) / 0.11);
	--shadow-elevation-high: 0px 0.2px 0.2px hsl(var(--shadow-color) / 0.14),
		0.1px 1.3px 1.4px -0.6px hsl(var(--shadow-color) / 0.13),
		0.2px 2.8px 2.9px -1.2px hsl(var(--shadow-color) / 0.12),
		0.5px 5.7px 6px -1.8px hsl(var(--shadow-color) / 0.11),
		0.9px 10.9px 11.5px -2.4px hsl(var(--shadow-color) / 0.11),
		1.5px 19.3px 20.3px -3px hsl(var(--shadow-color) / 0.1);
	--nav-height: 4rem; /* Default height to lower for header*/
	color-scheme: light dark;
}

/* Both for system and user preference */
:root[data-theme="dark"],
.dark-mode {
	--color-bg: black;
	--color-gray-20: #cccccc;
	--color-gray-50: #808080;
	--color-gray-90: #1a1a1a;
	--noise-opacity: 0.1;
	color-scheme: dark;
}

@font-face {
	font-weight: 500;
	src: url("/font/Switzer-Variable.subset.woff2") format("woff2");
	font-family: "Switzer";
	font-display: swap;
	/* font-variation-settings: "wght" 400; */
}
@font-face {
	font-style: normal italic;
	font-weight: 400;
	src:
		url("/font/Rag-Regular.subset.woff2") format("woff2"),
		url("/font/Rag-Italic.subset.woff2") format("woff2"),
		url("/font/Rag-Bold.subset.woff2") format("woff2"),
		url("/font/Rag-BoldItalic.subset.woff2") format("woff2");
	font-family: "Rag";
	font-display: swap;
}

/* Only set the overflow to the root */
html {
	contain: paint;
}
html,
body {
	max-width: 100%;
	padding: 0;
	background-color: Canvas;
	background-color: transparent;
	color: CanvasText;
	font-family: var(--font-family);
}

body {
	display: flex;
	flex-direction: row;
	min-height: 100vh;
	width: 100%;
	max-width: calc(40rem + 200px + 2rem);
	margin: 0 auto;
	padding: 0 1rem;
}

.site-header {
	position: sticky;
	top: 0;
	align-self: flex-start;
	width: 200px;
	height: 100vh;
	flex-shrink: 0;
	padding: 1rem;
}

main {
	width: 100%;
	max-width: 40rem;
	padding: 1rem;

	& h1:first-child,
	& h2:first-child,
	& h3:first-child {
		margin-top: 0;
	}

	/* Add a margin for when chat bubble is absolute */
	&:where(.chat-active) {
		margin-top: 3rem;
	}
}

/* Typography */
h1,
h2,
h3 {
	margin-top: 1.5rem;
	margin-bottom: 1rem;
}

h1,
h2,
h3,
.letter {
	text-wrap: balance;
	width: fit-content;
	font-family: "Switzer";
}

/* https://www.a11yproject.com/posts/how-to-hide-content/ */
.visually-hidden {
	clip: rect(0 0 0 0);
	position: absolute;
	width: 1px;
	height: 1px;
	overflow: hidden;
	white-space: nowrap;
	clip-path: inset(50%);
}

p:last-child {
	margin-bottom: 0;
}

/* Post navigation */
.post-nav {
	display: flex;
	flex-direction: row;
	justify-content: space-between;
	align-items: center;
	margin-top: 1rem;
}

.post-nav a {
	display: flex;
	align-items: center;
	text-decoration: none;
	color: var(--color-gray-20);
	max-width: 100%;
}

.post-nav:has(.post-nav-prev):has(.post-nav-next) a {
	max-width: calc(50% - 1rem);
}

.post-nav-prev {
	margin-right: auto;
}

.post-nav-next {
	margin-left: auto;
}

.post-nav-title {
	overflow: hidden;
	white-space: nowrap;
	text-overflow: ellipsis;
}

.post-nav-arrow {
	flex-shrink: 0;
	padding: 0 0.25rem;
}

.post-nav-divider {
	padding: 0 0.5rem;
	color: var(--color-gray-50);
}

table {
	margin: 1rem 0;
}
table td,
table th {
	padding-right: 1rem;
}

pre {
	border-radius: 0.25rem;
	box-shadow: var(--shadow-elevation-low);
}
pre,
code {
	font-family: var(--font-family-monospace);
}
pre:not([class*="language-"]) {
	-moz-tab-size: var(--syntax-tab-size);
	-o-tab-size: var(--syntax-tab-size);
	-webkit-hyphens: none;
	-ms-hyphens: none;
	margin: 0.5rem 0;
	line-height: 1.375; /* 22px /16 */
	hyphens: none;
	direction: ltr;
	text-align: left;
	white-space: pre;
	word-break: normal;
	word-spacing: normal;
	tab-size: var(--syntax-tab-size);
}
code {
	word-break: break-all;
}

/* Header */
.home-link {
	margin-right: 2rem;
	font-weight: 700;
	font-size: 1rem; /* 16px /16 */
}
.home-link:link:not(:hover) {
	text-decoration: none;
}

/* Nav */
nav {
	position: relative;
	width: 100%;
	list-style: none;
}
.nav-item {
	display: inline-block;
	padding: 0.25rem 0;
}
.nav-item a[href]:not(:hover) {
	text-decoration: none;
}
.nav a[href][aria-current="page"] {
	text-decoration: underline;
}

/* Posts list */
.postlist {
	padding: 0;
	list-style: none;
}

/* Each item in a po */
.postlist-item {
	display: flex;
	position: relative;
	flex-wrap: wrap;
	align-items: baseline;
	margin-bottom: 1rem;
	padding-left: 1.5rem; /* Add left padding to make room for the arrow */

	&::before {
		position: absolute;
		top: 0.2rem;
		left: 0;
		margin-right: 0.5rem;
		transform: scale(1);
		content: "\2192"; /* Default to arrow */
		color: var(--color-gray-20);
		filter: saturate(100%);
		transition: all 0.5s ease-out;
	}

	&[data-emoji]::before {
		content: attr(data-emoji);
	}

	&:hover::before,
	&:focus-within::before {
		animation: pulseSat 2s linear infinite;
	}

	&:not(:hover)::before {
		transform: scale(1);
		animation: none;
		filter: saturate(100%);
	}

	.postlist-date::after {
		visibility: hidden;
		position: absolute;
		max-width: calc(100% - 12rem);
		padding-left: 1rem;
		overflow: hidden;
		content: attr(data-tooltip);
		color: var(--color-gray-20);
		text-overflow: ellipsis;
		white-space: nowrap;
		opacity: 0;
		transition:
			opacity 0.3s ease,
			visibility 0.3s ease;
	}

	&:has(.postlist-link:hover) .postlist-date::after {
		visibility: visible;
		opacity: 1;
	}

	&-active .postlist-link {
		font-weight: bold;
	}
}

@keyframes pulseSat {
	0%,
	50%,
	100% {
		transform: scale(1);
		filter: saturate(100%);
	}
	25% {
		transform: scale(0.8);
		filter: saturate(50%);
	}
	75% {
		transform: scale(1.2);
		filter: saturate(150%);
	}
}
.postlist-date {
	color: var(--color-gray-20);
	font-size: 0.8125rem; /* 13px /16 */
	word-spacing: -0.5px;
}
.postlist-link {
	flex-basis: 100%;
	font-weight: 700;
	font-size: 1.1875rem; /* 19px /16 */
	text-decoration-thickness: 1px;
	text-underline-position: from-font;
	text-underline-offset: 0;
}

/* Tags */
.post-tag {
	display: inline-flex;
	align-items: center;
	justify-content: center;
	font-style: italic;
	text-transform: capitalize;
}
.postlist-item > .post-tag {
	align-self: center;
}

/* Tags list */
.post-metadata {
	display: inline-flex;
	flex-wrap: wrap;
	margin: 0;
	padding: 0;
	gap: 0.5rem;
	list-style: none;
}
.post-metadata time {
	margin-right: 1rem;
}

/* Direct Links / Markdown Headers */
.header-anchor {
	margin-left: 0.1rem;
	font-style: normal;
	text-decoration: none;
}
a[href].header-anchor,
a[href].header-anchor:visited {
	color: transparent;
}
a[href].header-anchor:focus,
a[href].header-anchor:hover {
	text-decoration: underline;
}
a[href].header-anchor:focus,
:hover > a[href].header-anchor {
	color: #aaa;
}

h2 + .header-anchor {
	font-size: 1.5rem;
}

/* Figures */
figure {
	margin: 1rem 0;
}
figure > * {
	max-width: 100%;
	margin: 0 auto;
}
/* All images & videos should be in a figure */
figure :first-child {
	border-radius: 0.25rem;
	box-shadow: var(--shadow-elevation-low);
}

figcaption {
	margin-top: 0.5rem;
	color: var(--color-gray-50);
	text-align: center;
}

blockquote {
	padding-left: 1rem;
	border-left: 2px solid ButtonFace;
}

/* Talk bubble styling */
.nav-phrase {
	display: none;
	width: 100%;
	padding: 0 0.5rem;
	cursor: text;
}

.nav-bubble {
	display: flex;
	position: absolute;
	align-items: center;
	justify-content: space-between;
	width: calc(100% - 2.5rem);
	margin: 0;
	padding: calc(0.25rem - 1px);
	transform: translateY(calc(var(--item-top) - 12px));
	border: 1px solid var(--color-gray-90);
	border-radius: 0.25rem;
	background: ButtonFace;
	transition: transform 0.3s ease;

	&:before,
	&:after {
		position: absolute;
		top: 10px;
		right: -7.5px;
		width: 0;
		height: 0;
		border: 8px solid transparent;
		border-right: 0;
		content: "";
	}

	&:before {
		right: -9px;
		border-left-color: var(--color-gray-90);
	}

	&:after {
		border-left-color: ButtonFace;
	}

	/* Reset position when chat is active */
	&:where(.chat-active) {
		transform: none;
	}
}

/* Talk bubble movement */
header {
	/* We need to add 1 to the active item to account for the first item */
	--item-top: calc(12px + var(--nav-item-active, 1) * var(--nav-item-height));
	--nav-item-height: 36px;
	z-index: 1; /* Ensure the header is above other elements */

	display: flex;
	flex-direction: column;
	align-items: flex-end;
	justify-content: flex-start;
	width: 200px;
	height: 100vh;
	padding: 1rem;

	&:not(:has(+ .chat-active)) {
		&:has(.nav-item:nth-child(n):hover) {
			--n: var(--n);
			--item-top: calc(12px + (var(--n) - 1) * var(--nav-item-height));
		}
		&:has(.nav-item:nth-child(1):hover) {
			--n: 1;
		}
		&:has(.nav-item:nth-child(2):hover) {
			--n: 2;
		}
		&:has(.nav-item:nth-child(3):hover) {
			--n: 3;
		}
		&:has(.nav-item:nth-child(4):hover) {
			--n: 4;
		}
		&:has(.nav-item:nth-child(5):hover) {
			--n: 5;
		}
	}
}

.side-nav {
	display: flex;
	justify-content: center;
	width: 100%;
	padding-right: 2rem;
}

.nav-list {
	display: flex;
	z-index: 1;
	flex-direction: column;
	width: 100%;
	margin: 0;
	padding-right: 1rem;
	padding-inline-start: 0;
	list-style: none;
	text-align: right;
}

.theme-toggle {
	position: relative;
	right: -2.25rem;
	align-self: flex-start;
	margin-left: auto;
	transition: transform 0.3s ease;
}

#chat-toggle {
	cursor: pointer;
}

/* Dark mode toggle styles */
#dark-mode-toggle {
	display: none;
}

#dark-mode-toggle + label {
	border: none;
	background: none;
	font-size: 1rem;
	cursor: pointer;
}

#dark-mode-toggle + label::before {
	content: "🐓";
}

#dark-mode-toggle:checked + label::before {
	content: "🐸";
}

@media (prefers-color-scheme: dark) {
	#dark-mode-toggle:not(:checked) + label::before {
		content: "🐓";
	}
	#dark-mode-toggle:checked + label::before {
		content: "🐸";
	}
}

:root:has(#dark-mode-toggle:checked) {
	color-scheme: dark;
}

:root:has(#dark-mode-toggle:not(:checked)) {
	color-scheme: light;
}

/* Chat bubble related */
#user-input {
	width: 100%;
	/* Mozilla? */
	padding: 0;
	border: none;
	outline: none;
	background: none;
	color: inherit;
	font-size: inherit;
	font-family: inherit;
}

#user-input::placeholder,
.waiting {
	color: var(--color-gray-50);
	opacity: 0.7;
}

#chat-form {
	width: 100%;
}

#chat-form button {
	display: none;
}

@keyframes ellipsis {
	0% {
		content: ".";
	}
	33% {
		content: "..";
	}
	66% {
		content: "...";
	}
}

.waiting::after {
	display: inline-block;
	width: 1rem;
	content: ".";
	text-align: left;
	animation: ellipsis 1s infinite;
}

/* Chat reset */
.chat-reset {
	display: none;
	position: relative;
	align-self: flex-start;
	padding: 0 0.5rem;
	border: none;
	background: none;
	color: gray;
	cursor: pointer;
}

/* Add shadow to nav bubble */
.nav-bubble {
	box-shadow: var(--shadow-elevation-low);
}
.nav-bubble.chat-active {
	position: absolute;
	box-shadow: var(--shadow-elevation-medium);
}

.nav-bubble.chat-active .chat-reset {
	display: inline-block;
}

/* Only do nav switch on wide screens */
@media (min-width: 840px) {
	.nav-bubble {
		&:where(.chat-active) {
			/* left: calc(50% + 200px); */
			/* width: calc(640px - 200px); */
			left: calc(200px);
			width: calc(640px - 4.5rem);
		}

		&:where(.chat-active) > * {
			display: inline-block;
		}
	}
}

/* For mobile view */
@media (max-width: 839px) {
	/* Switch side nav off */
	.side-nav {
		display: none;
	}

	/* Mobile */
	.nav-phrase {
		display: inline-block;
	}

	body {
		flex-direction: column; /* Stack header and main content on narrow screens */
		max-width: 40rem;
		padding: 0;
	}

	main {
		max-width: none;
		padding: 1rem;
	}

	.site-header {
		position: relative;
		width: 100%; /* Full width on narrow screens */
		max-width: 640px;
		height: auto;
		padding-bottom: 0;
		gap: 1rem 0.5rem;
	}

	/* Mobile-specific nav bubble styles */
	.nav-bubble {
		position: relative;
		left: initial;
		transform: none;
	}

	header {
		position: relative;
		height: auto;
		width: 100%;
		align-items: flex-start;
	}
}

/* Util */
.line-clamp {
	-webkit-box-orient: vertical;
	display: -webkit-box;
	line-clamp: 2;
	-webkit-line-clamp: 2;
	overflow: hidden;
}

.noise-container {
	z-index: -1;
	position: fixed;
	top: 0;
	left: 0;
	width: 100%;
	height: 100%;
	background-image: var(--noise-img);
	background-size: 182px;
	background-repeat: repeat;
	opacity: var(--noise-opacity);
	pointer-events: none;
}

/* Spotify widget */
.spotify-widget img {
	display: inline-block;
	border-radius: 0.25rem;
	box-shadow: var(--shadow-elevation-low);
}

/* Sidebar progress bar */
.progress-bar {
	position: fixed;
	top: 0;
	left: 0;
	width: 0.5rem;
	height: 100vh;
	transform: scaleY(0);
	transform-origin: 0 0;
	background-color: var(--color-gray-50);
}

@supports (animation-timeline: scroll()) {
	html {
		-ms-overflow-style: none; /* Internet Explorer 10+ */
		scrollbar-width: none; /* Firefox */
	}

	html::-webkit-scrollbar {
		display: none; /* Chrome, Safari, and Opera */
		width: 0;
		height: 0;
	}

	.progress-bar {
		animation-timeline: scroll(root block);
		animation-range: entry 0% cover 100%;
		animation: grow-progress linear;
	}

	@keyframes grow-progress {
		to {
			transform: scaleY(1);
		}
	}
}

/* Citation */
.citation {
	margin-bottom: 1rem;
	padding-left: 2rem;
	text-indent: -2rem;
}

.citation p {
	margin: 0;
}

/* Search results */
#search-results {
	max-height: 50vh;
	overflow-y: auto;
}
#search-results:has(.search-result) {
	margin-top: 0.25rem;
	border-top: 1px solid var(--color-gray-90);
}

.search-result {
	--border-width: 0px;
	display: block;
	padding: 0.5rem 1rem;
	border-bottom: 1px solid var(--color-gray-90);
	background: linear-gradient(var(--color-gray-50), var(--color-gray-50))
		left/var(--border-width) 100% no-repeat;
	color: inherit;
	text-decoration: none;
	transition: 0.3s ease;
	transition-property: background-size, background-color;
}

.search-result:hover {
	--border-width: 3px;
	background-color: var(--color-gray-90);
}

.search-result a {
	color: var(--color-gray-20);
	font-weight: bold;
	text-decoration: none;
}

.search-result p {
	margin: 0;
	color: var(--color-gray-50);
}

/* Wave divider */
#post-title {
	margin-bottom: 0.5rem;
}

:root {
	--wave-width: 30px;
	--wave-height: 10px;
}

.wave-divider {
	width: 100%;
	height: var(--wave-height);
	margin: 2rem 0;
	/* margin-top: 0.3rem;
	margin-bottom: 1rem; */
	background-color: var(--emoji-color);

	/* Wave mask */
	--wave-mask: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='60' height='10'%3E%3Cpath d='M0 5q15-5 30 0t30 0' stroke='white' fill='none' stroke-width='1.5'/%3E%3C/svg%3E");

	/* Fade-out mask */
	--fade-mask: linear-gradient(
		to right,
		transparent,
		black 15%,
		black 85%,
		transparent
	);

	/* Combine masks */
	mask-image: var(--wave-mask), var(--fade-mask);
	mask-size:
		var(--wave-width) var(--wave-height),
		100% 100%;
	mask-repeat: repeat-x, no-repeat;
	mask-composite: intersect;

	/* For webkit browsers */
	-webkit-mask-image: var(--wave-mask), var(--fade-mask);
	-webkit-mask-size:
		var(--wave-width) var(--wave-height),
		100% 100%;
	-webkit-mask-repeat: repeat-x, no-repeat;
	-webkit-mask-composite: source-in;

	animation: wave-animation 5s linear infinite;
}

@keyframes wave-animation {
	0% {
		mask-position:
			0 0,
			0 0;
		-webkit-mask-position:
			0 0,
			0 0;
	}
	100% {
		mask-position:
			var(--wave-width) 0,
			0 0;
		-webkit-mask-position:
			var(--wave-width) 0,
			0 0;
	}
}


		
		
			/* PrismJS 1.29.0
https://prismjs.com/download.html#themes=prism-tomorrow&languages=markup+css+clike+javascript+bash+python */
code[class*=language-],pre[class*=language-]{color:#ccc;background:0 0;font-family:Consolas,Monaco,'Andale Mono','Ubuntu Mono',monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none}pre[class*=language-]{padding:1em;margin:.5em 0;overflow:auto}:not(pre)>code[class*=language-],pre[class*=language-]{background:#2d2d2d}:not(pre)>code[class*=language-]{padding:.1em;border-radius:.3em;white-space:normal}.token.block-comment,.token.cdata,.token.comment,.token.doctype,.token.prolog{color:#999}.token.punctuation{color:#ccc}.token.attr-name,.token.deleted,.token.namespace,.token.tag{color:#e2777a}.token.function-name{color:#6196cc}.token.boolean,.token.function,.token.number{color:#f08d49}.token.class-name,.token.constant,.token.property,.token.symbol{color:#f8c555}.token.atrule,.token.builtin,.token.important,.token.keyword,.token.selector{color:#cc99cd}.token.attr-value,.token.char,.token.regex,.token.string,.token.variable{color:#7ec699}.token.entity,.token.operator,.token.url{color:#67cdcc}.token.bold,.token.important{font-weight:700}.token.italic{font-style:italic}.token.entity{cursor:help}.token.inserted{color:green}

			lite-youtube {
    background-color: #000;
    position: relative;
    display: block;
    contain: content;
    background-position: center center;
    background-size: cover;
    cursor: pointer;
    max-width: 720px;
}

/* gradient */
lite-youtube::before {
    content: attr(data-title);
    display: block;
    position: absolute;
    top: 0;
    /* Pixel-perfect port of YT's gradient PNG, using https://github.com/bluesmoon/pngtocss plus optimizations */
    background-image: linear-gradient(180deg, rgb(0 0 0 / 67%) 0%, rgb(0 0 0 / 54%) 14%, rgb(0 0 0 / 15%) 54%, rgb(0 0 0 / 5%) 72%, rgb(0 0 0 / 0%) 94%);
    height: 99px;
    width: 100%;
    font-family: "YouTube Noto",Roboto,Arial,Helvetica,sans-serif;
    color: hsl(0deg 0% 93.33%);
    text-shadow: 0 0 2px rgba(0,0,0,.5);
    font-size: 18px;
    padding: 25px 20px;
    overflow: hidden;
    white-space: nowrap;
    text-overflow: ellipsis;
    box-sizing: border-box;
}

lite-youtube:hover::before {
    color: white;
}

/* responsive iframe with a 16:9 aspect ratio
    thanks https://css-tricks.com/responsive-iframes/
*/
lite-youtube::after {
    content: "";
    display: block;
    padding-bottom: calc(100% / (16 / 9));
}
lite-youtube > iframe {
    width: 100%;
    height: 100%;
    position: absolute;
    top: 0;
    left: 0;
    border: 0;
}

/* play button */
lite-youtube > .lty-playbtn {
    display: block;
    /* Make the button element cover the whole area for a large hover/click target… */
    width: 100%;
    height: 100%;
    /* …but visually it's still the same size */
    background: no-repeat center/68px 48px;
    /* YT's actual play button svg */
    background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 68 48"><path d="M66.52 7.74c-.78-2.93-2.49-5.41-5.42-6.19C55.79.13 34 0 34 0S12.21.13 6.9 1.55c-2.93.78-4.63 3.26-5.42 6.19C.06 13.05 0 24 0 24s.06 10.95 1.48 16.26c.78 2.93 2.49 5.41 5.42 6.19C12.21 47.87 34 48 34 48s21.79-.13 27.1-1.55c2.93-.78 4.64-3.26 5.42-6.19C67.94 34.95 68 24 68 24s-.06-10.95-1.48-16.26z" fill="red"/><path d="M45 24 27 14v20" fill="white"/></svg>');
    position: absolute;
    cursor: pointer;
    z-index: 1;
    filter: grayscale(100%);
    transition: filter .1s cubic-bezier(0, 0, 0.2, 1);
    border: 0;
}

lite-youtube:hover > .lty-playbtn,
lite-youtube .lty-playbtn:focus {
    filter: none;
}

/* Post-click styles */
lite-youtube.lyt-activated {
    cursor: unset;
}
lite-youtube.lyt-activated::before,
lite-youtube.lyt-activated > .lty-playbtn {
    opacity: 0;
    pointer-events: none;
}

.lyt-visually-hidden {
    clip: rect(0 0 0 0);
    clip-path: inset(50%);
    height: 1px;
    overflow: hidden;
    position: absolute;
    white-space: nowrap;
    width: 1px;
  }
		</style>
	</head>

	<body style="--nav-item-active: 1;">
		<div class="noise-container"></div>
		<a href="#skip" class="visually-hidden">Skip to main content</a>

		<header class="site-header">
			<nav>
				<h2 class="visually-hidden">Top level navigation menu</h2>
				<div class="nav-bubble">
    <button id="chat-reset" class="chat-reset" aria-label="Reset chat">↺</button>
    <div id="navPhrase" class="nav-phrase">
        
            
            <a href="/" style="text-decoration: none;">Home</a>&emsp;<a href="/projects/" style="text-decoration: none;">Projects</a>&emsp;<a href="/blog/" style="text-decoration: none;">Blog</a>&emsp;<a href="/about/" style="text-decoration: none;">About Me</a>
        
    </div>
    <form method="post" id="theme-form" class="theme-toggle">
        <input type="checkbox" id="dark-mode-toggle" name="theme" value="dark" aria-label="Toggle dark mode">
        <label for="dark-mode-toggle"></label>
    </form>
</div>
				<div class="side-nav">
					<ul class="nav-list">
						<li id="chat-toggle" class="nav-item">Welcome!</li>
							<li class="nav-item">
								<a href="/">Home</a>
							</li>
							<li class="nav-item">
								<a href="/projects/">Projects</a>
							</li>
							<li class="nav-item">
								<a href="/blog/">Blog</a>
							</li>
							<li class="nav-item">
								<a href="/about/">About Me</a>
							</li>
					</ul>
				</div>
			</nav>
		</header>

		<main id="skip">
			


<div class="progress-bar"></div>

<article class="post">
  <h1 id="post-title">
    Meet in Space: Video Conferencing in Spatial Audio&ensp;🪐
  </h1>

  <ul class="post-metadata">
    <li>
      <time datetime="2021-05-18">18 May 2021</time>
    </li>
      <li>
        <a href="/tags/projects/" class="post-tag">projects</a>
      </li>
  </ul>

  <div class="wave-divider" style="--emoji-color: #d4ceb0;"></div>

  <h2 id="toward-a-telepresence-of-sound" tabindex="-1">Toward a Telepresence of Sound <a class="header-anchor" href="#toward-a-telepresence-of-sound">#</a></h2>
<p>Digital communications technologies have developed at an increasingly rapid pace, with the COVID-19 pandemic accelerating its recent adoption. This shift over the last few decades has seen a mass migration online, where utilities like video conferencing software have become essential to entire industries and institutions. Yet, there are clear limitations with this new digital work space - most of which exist from the nuance of natural communication. My master's thesis for the Music, Communications and Technology program at the University of Oslo and Norwegian University of Science and Technology proposes the integration of binaural spatialized audio within a web-based video conferencing platform for small-group, distributed conversations. The proposed system builds upon findings on the benefits of spatial audio in video conferencing platforms and is guided by the tenets of telepresence. The developed implementation is based on Jitsi Meet, a robust open-source conferencing system. It localizes participant’s voices through sound spatialization methods provided by the Web Audio API, a modern library in JavaScript for complex audio manipulation on the web.</p>
<p>This project treads new ground in exploring how localized audio can be conceptualized within an accessible telecommunications platform, proposing a novel integration of HRTF-based binaural spatialization within a standard video conferencing layout. A novel system design and experimental questions used in a technical evaluation and user study are informed from a review of audio and video conference systems found in the literature and commercial market. The system evaluation suggests its viability from a compatibility and performance perspective. Perceptual metrics of cognitive load, social presence, and intelligibility are further investigated by a user study where four remote subjects were asked to engage in a short group discussion on a live deployment of the system. Results find support for improvements across all defined metrics as well as increased opinion scores regarding the preference of conferencing with a spatial audio system.</p>
<h2 id="teleconferencing-is-here-to-stay" tabindex="-1">Teleconferencing is Here to Stay <a class="header-anchor" href="#teleconferencing-is-here-to-stay">#</a></h2>
<p>But is often a tiring affair...</p>
<ul>
<li>&quot;Zoom&quot; fatigue</li>
<li>Reduced dimensionality</li>
<li>Poor and inconsistent quality</li>
</ul>
<p>Teleconferencing has become apart of many of our daily rituals, either a result of the COVID epidemic or the rapid digitization of communication. However, most of us have experienced some symptom of fatigue as a result of our extended use of the system. Latency, network reliability, visual and audio fidelity can all contribute to a fatiguing experience, but software can also play a major role.</p>
<h2 id="issues-in-teleconferencing" tabindex="-1">Issues in Teleconferencing <a class="header-anchor" href="#issues-in-teleconferencing">#</a></h2>
<p>My take:</p>
<ul>
<li>Don't reinvent the wheel - instead focus on one critical component</li>
<li>How can the treatment of audio bring us to the goal of telepresence, and closer to realistic conversations</li>
</ul>
<p>There is a striking lack of realism in our video meetings, especially in how our voices are conveyed through digital exchange. This project is guided by the principles of telepresence, or the goal of conveying our sensory interactions in high fidelity, as we would in a face-to-face interaction. Every acoustic interaction we experience is spatial so aren't our digital interactions?</p>
<h2 id="replicating-face-to-face-interactions" tabindex="-1">Replicating Face-to-face Interactions <a class="header-anchor" href="#replicating-face-to-face-interactions">#</a></h2>
<ul>
<li>Spatial model, spatial audio
<ul>
<li>Visual-aural coherency</li>
<li>Binaural audio</li>
</ul>
</li>
<li>Benefits from the literature
<ul>
<li>Lateralizing audio can improve intelligibility</li>
<li>Disentangle double-talk</li>
<li>And more: reduce cognitive load, improve comprehension, and is generally more favorable</li>
</ul>
</li>
</ul>
<p>There are many issues that ought to be addressed in the field from a software and user experience perspective. Given that audio appears the most critical medium in task oriented communication, I chose to work on integrating spatial audio within a teleconferencing system. Spatial audio within telecommunication has a number of cool benefits and has not yet been integrated within a standard video conferencing platform.</p>
<h2 id="jitsi-meet-and-web-audio" tabindex="-1">Jitsi Meet and Web Audio <a class="header-anchor" href="#jitsi-meet-and-web-audio">#</a></h2>
<p>Jitsi Meet is one of the most popular FOSS video conferencing applications that requires no sign up or installation. It works cross browser and has a great support community.</p>
<p>To achieve spatial audio, the only current possibility for high-fidelity reproduction of sound is through binaural production of sound via headphones. Fortunately, WebAudio, a standardized method supported on all browsers, is able to faciliate full HRTF based binaural audio.</p>
<h2 id="implementation" tabindex="-1">Implementation <a class="header-anchor" href="#implementation">#</a></h2>
<ul>
<li>Capturing participants' audio streams (WebRTC)</li>
<li>Head-related transfer functions via PannerNode</li>
<li>Dynamic processing of participants</li>
</ul>
<p>With this, I integrated dynamic, toggle-able, spatial audio for each participant audio stream in a meeting. The voices of the participants appear coherent with the video streams as participants appear and disappear.</p>
<figure>
				<lite-vimeo videoid="548286337" style="aspect-ratio: 16/9;">
					<div class="ltv-playbtn"></div>
				</lite-vimeo>
				<figcaption>Demo of Meet in Space</figcaption>
			</figure>
<h2 id="validating-with-a-user-study" tabindex="-1">Validating with a User Study <a class="header-anchor" href="#validating-with-a-user-study">#</a></h2>
<p>After a technical evaluation of the system suggested its ability to scale at least to 5 concurrent participants, I ran a user study consisting of students from MCT as well as other's who were experienced with conferencing on a daily basis. The experiment consisted of a brief conversation among 4 users, with and without spatial audio. The results, while preliminary, were promising and appear to support previous findings in the literature.</p>
<p>There was support for four hypotheses of perceived metrics:</p>
<ul>
<li>Decreased cognitive effort</li>
<li>Increased social presence</li>
<li>Increased vocal intelligibility</li>
<li>Increase in opinion score</li>
</ul>
<h2 id="and-the-future" tabindex="-1">And the future? <a class="header-anchor" href="#and-the-future">#</a></h2>
<p>Spatial audio is being adopted at a rapid pace, but has still yet to be introduced in small group interactions like the ones presented here. Hopefully, this thesis can provide a valid proof of concept for the benefits of spatial audio in video conferencing platforms.</p>


  <div class="wave-divider" style="--emoji-color: #d4ceb0;"></div>
    <nav class="post-nav">
        <a href="/projects/2020-10-23-film-for-music/" class="post-nav-prev">
          <span class="post-nav-arrow">←</span>
          <span class="post-nav-title">Music for a Series of Scenes</span>
        </a>
        <span class="post-nav-divider">•</span>
        <a href="/projects/2024-05-01-cacophony/" class="post-nav-next">
          <span class="post-nav-title">Sound Pedro 2024: Cacophony</span>
          <span class="post-nav-arrow">→</span>
        </a>
    </nav>
</article>
		</main>

		<footer></footer>

		<!-- This page `/projects/2021-05-14-meet-in-space/` was built on 2024-09-26T01:26:47.697Z -->
	</body>
</html>
<script defer>
	// Minimal JS for handling user preference
(function () {
    const toggle = document.getElementById('dark-mode-toggle');

    // Set initial state based on localStorage or system preference
    const storedTheme = localStorage.getItem('color-scheme');
    if (storedTheme) {
        document.documentElement.setAttribute('data-theme', storedTheme);
        toggle.checked = storedTheme === 'dark';
    }

    // Handle toggle changes
    toggle.addEventListener('change', () => {
        const newTheme = toggle.checked ? 'dark' : 'light';
        document.documentElement.setAttribute('data-theme', newTheme);
        localStorage.setItem('color-scheme', newTheme);
    });

    // const form = document.getElementById('theme-form');
    // Handle form submission (for no-JS fallback)
    // form.addEventListener('submit', (e) => {
    //     e.preventDefault();
    //     const formData = new FormData(form);
    //     fetch('/set-theme', {
    //         method: 'POST',
    //         body: formData
    //     }).then(() => {
    //         location.reload();
    //     });
    // });
})();

		// Generate a random user ID if not already stored
function getUserId() {
	return (
		localStorage.getItem("userId") ||
		localStorage.setItem(
			"userId",
			"user_" + Math.random().toString(36).slice(2, 11),
		)
	);
}

function sendMessageToWorker(message) {
	const baseUrl =
		window.location.hostname === "localhost" ||
		window.location.hostname === "127.0.0.1"
			? "http://localhost:8090"
			: "";
	const isDarkMode =
		document.documentElement.getAttribute("data-theme") === "dark";
	const animalParam = isDarkMode ? "frog" : "chicken";

	updateNavPhrase(isDarkMode ? "Ribbit" : "Cluck", true);

	// Get the body content
	const bodyContent = document.body.innerText;

	// Prepare the message with the body content
	const fullMessage = `Current page content:\n${bodyContent}\n\nUser message: ${message}`;

	fetch(
		`${baseUrl}/ai?message=${encodeURIComponent(fullMessage)}&animal=${animalParam}&userId=${getUserId()}`,
	)
		.then((response) => {
			if (!response.ok)
				throw new Error(`HTTP error! status: ${response.status}`);
			return response.body.getReader();
		})
		.then((reader) => {
			let accumulatedResponse = "";

			function readStream() {
				let buffer = "";
				reader.read().then(function processText({ done, value }) {
					if (done) {
						updateNavPhrase(accumulatedResponse, false);
						return;
					}

					buffer += new TextDecoder().decode(value);
					let newlineIndex;
					while ((newlineIndex = buffer.indexOf("\n")) !== -1) {
						const line = buffer.slice(0, newlineIndex);
						buffer = buffer.slice(newlineIndex + 1);

						if (line.startsWith("data: ")) {
							try {
								const jsonStr = line.slice(5).trim();
								if (jsonStr === "[DONE]") {
									updateNavPhrase(accumulatedResponse, false);
									return;
								}
								const data = JSON.parse(jsonStr);
								if (data.response) {
									accumulatedResponse += data.response;
									updateNavPhrase(accumulatedResponse, false);
								}
							} catch (error) {
								buffer = line + "\n" + buffer;
								break;
							}
						}
					}

					return reader.read().then(processText);
				});
			}

			readStream();
		})
		.catch((error) => {
			console.error("Fetch error:", error);
			updateNavPhrase("Sorry, something went wrong.");
		});
}

function updateNavPhrase(text, isWaiting = false) {
	const navPhrase = document.getElementById("navPhrase");
	navPhrase.textContent = text;
	navPhrase.classList.toggle("waiting", isWaiting);
	navPhrase.classList.toggle("clickable", !isWaiting && text.length > 0);
}

document.addEventListener("DOMContentLoaded", function () {
	const chatTrigger = document.getElementById("chat-toggle");
	const talkBubble = document.querySelector(".nav-bubble");
	const mainContent = document.querySelector("main");
	const navPhrase = document.getElementById("navPhrase");
	const chatReset = document.getElementById("chat-reset");
	let originalContent = navPhrase.innerHTML;

	function resetChatInterface() {
		navPhrase.innerHTML = originalContent;
		talkBubble.classList.remove("chat-active");
		mainContent.classList.remove("chat-active");
	}

	chatReset.addEventListener("click", resetChatInterface);

	function activateChatInterface() {
		navPhrase.innerHTML = `
		<form id="chat-form">
		  <input type="text" id="user-input" placeholder="Search... or say hi?">
		  <button type="submit" style="display:none;">Send</button>
		</form>
		<div id="search-results"></div>
	  `;
		document.getElementById("user-input").focus();

		const searchResults = document.getElementById("search-results");
		let pagefind;

		document
			.getElementById("user-input")
			.addEventListener("input", async function () {
				if (!pagefind) {
					pagefind = await import("/pagefind/pagefind.js");
					await pagefind.options({
						element: "#search-results",
						excerptLength: 15,
						highlightParam: "highlight",
					});
					await pagefind.init();
				}

				const query = this.value.trim();
				if (query.length > 2) {
					const search = await pagefind.search(query);
					const results = await Promise.all(
						search.results.map((r) => r.data()),
					);

					searchResults.innerHTML =
						results.length > 0
							? results
									.map(
										(result) => `
			<a href="${result.url}" class="search-result">
			  <div class="search-result-title">${result.meta.title || "Untitled"}</div>
			  <p>${result.excerpt}</p>
			</a>
		  `,
									)
									.join("")
							: "";
					talkBubble.classList.add("chat-active");
				} else {
					searchResults.innerHTML = "";
				}
			});

		document
			.getElementById("chat-form")
			.addEventListener("submit", function (e) {
				e.preventDefault();
				const userInput = document.getElementById("user-input");
				if (userInput.value.trim() !== "") {
					sendMessageToWorker(userInput.value.trim());
					userInput.value = "";
					searchResults.innerHTML = "";
				}
			});

		document
			.getElementById("user-input")
			.addEventListener("keydown", function (e) {
				if (e.key === "Escape") resetChatInterface();
			});
	}

	function handleChatTrigger() {
		talkBubble.classList.toggle("chat-active");
		mainContent.classList.toggle("chat-active");
		talkBubble.classList.contains("chat-active")
			? activateChatInterface()
			: (navPhrase.innerHTML = originalContent);
	}

	chatTrigger.addEventListener("click", handleChatTrigger);

	navPhrase.addEventListener("click", function (event) {
		if (event.target.tagName.toLowerCase() === "a") return;
		if (
			window.innerWidth < 840 &&
			!talkBubble.classList.contains("chat-active")
		) {
			handleChatTrigger();
		} else if (navPhrase.classList.contains("clickable")) {
			activateChatInterface();
			navPhrase.classList.remove("clickable");
		}
	});
});


		
			
			/**
 * A lightweight youtube embed. Still should feel the same to the user, just MUCH faster to initialize and paint.
 *
 * Thx to these as the inspiration
 *   https://storage.googleapis.com/amp-vs-non-amp/youtube-lazy.html
 *   https://autoplay-youtube-player.glitch.me/
 *
 * Once built it, I also found these:
 *   https://github.com/ampproject/amphtml/blob/master/extensions/amp-youtube (👍👍)
 *   https://github.com/Daugilas/lazyYT
 *   https://github.com/vb/lazyframe
 */
class LiteYTEmbed extends HTMLElement {
    connectedCallback() {
        this.videoId = this.getAttribute('videoid');

        let playBtnEl = this.querySelector('.lty-playbtn');
        // A label for the button takes priority over a [playlabel] attribute on the custom-element
        this.playLabel = (playBtnEl && playBtnEl.textContent.trim()) || this.getAttribute('playlabel') || 'Play';

        this.dataset.title = this.getAttribute('title') || "";

        /**
         * Lo, the youtube poster image!  (aka the thumbnail, image placeholder, etc)
         *
         * See https://github.com/paulirish/lite-youtube-embed/blob/master/youtube-thumbnail-urls.md
         */
        if (!this.style.backgroundImage) {
          this.style.backgroundImage = `url("https://i.ytimg.com/vi/${this.videoId}/hqdefault.jpg")`;
          this.upgradePosterImage();
        }

        // Set up play button, and its visually hidden label
        if (!playBtnEl) {
            playBtnEl = document.createElement('button');
            playBtnEl.type = 'button';
            playBtnEl.classList.add('lty-playbtn');
            this.append(playBtnEl);
        }
        if (!playBtnEl.textContent) {
            const playBtnLabelEl = document.createElement('span');
            playBtnLabelEl.className = 'lyt-visually-hidden';
            playBtnLabelEl.textContent = this.playLabel;
            playBtnEl.append(playBtnLabelEl);
        }

        this.addNoscriptIframe();

        // for the PE pattern, change anchor's semantics to button
        if(playBtnEl.nodeName === 'A'){
            playBtnEl.removeAttribute('href');
            playBtnEl.setAttribute('tabindex', '0');
            playBtnEl.setAttribute('role', 'button');
            // fake button needs keyboard help
            playBtnEl.addEventListener('keydown', e => {
                if( e.key === 'Enter' || e.key === ' ' ){
                    e.preventDefault();
                    this.activate();
                }
            });
        }

        // On hover (or tap), warm up the TCP connections we're (likely) about to use.
        this.addEventListener('pointerover', LiteYTEmbed.warmConnections, {once: true});
        this.addEventListener('focusin', LiteYTEmbed.warmConnections, {once: true});

        // Once the user clicks, add the real iframe and drop our play button
        // TODO: In the future we could be like amp-youtube and silently swap in the iframe during idle time
        //   We'd want to only do this for in-viewport or near-viewport ones: https://github.com/ampproject/amphtml/pull/5003
        this.addEventListener('click', this.activate);

        // Chrome & Edge desktop have no problem with the basic YouTube Embed with ?autoplay=1
        // However Safari desktop and most/all mobile browsers do not successfully track the user gesture of clicking through the creation/loading of the iframe,
        // so they don't autoplay automatically. Instead we must load an additional 2 sequential JS files (1KB + 165KB) (un-br) for the YT Player API
        // TODO: Try loading the the YT API in parallel with our iframe and then attaching/playing it. #82
        this.needsYTApi = this.hasAttribute("js-api") || navigator.vendor.includes('Apple') || navigator.userAgent.includes('Mobi');
    }

    /**
     * Add a <link rel={preload | preconnect} ...> to the head
     */
    static addPrefetch(kind, url, as) {
        const linkEl = document.createElement('link');
        linkEl.rel = kind;
        linkEl.href = url;
        if (as) {
            linkEl.as = as;
        }
        document.head.append(linkEl);
    }

    /**
     * Begin pre-connecting to warm up the iframe load
     * Since the embed's network requests load within its iframe,
     *   preload/prefetch'ing them outside the iframe will only cause double-downloads.
     * So, the best we can do is warm up a few connections to origins that are in the critical path.
     *
     * Maybe `<link rel=preload as=document>` would work, but it's unsupported: http://crbug.com/593267
     * But TBH, I don't think it'll happen soon with Site Isolation and split caches adding serious complexity.
     */
    static warmConnections() {
        if (LiteYTEmbed.preconnected) return;

        // The iframe document and most of its subresources come right off youtube.com
        LiteYTEmbed.addPrefetch('preconnect', 'https://www.youtube-nocookie.com');
        // The botguard script is fetched off from google.com
        LiteYTEmbed.addPrefetch('preconnect', 'https://www.google.com');

        // Not certain if these ad related domains are in the critical path. Could verify with domain-specific throttling.
        LiteYTEmbed.addPrefetch('preconnect', 'https://googleads.g.doubleclick.net');
        LiteYTEmbed.addPrefetch('preconnect', 'https://static.doubleclick.net');

        LiteYTEmbed.preconnected = true;
    }

    fetchYTPlayerApi() {
        if (window.YT || (window.YT && window.YT.Player)) return;

        this.ytApiPromise = new Promise((res, rej) => {
            var el = document.createElement('script');
            el.src = 'https://www.youtube.com/iframe_api';
            el.async = true;
            el.onload = _ => {
                YT.ready(res);
            };
            el.onerror = rej;
            this.append(el);
        });
    }

    /** Return the YT Player API instance. (Public L-YT-E API) */
    async getYTPlayer() {
        if(!this.playerPromise) {
            await this.activate();
        }

        return this.playerPromise;
    }

    async addYTPlayerIframe() {
        this.fetchYTPlayerApi();
        await this.ytApiPromise;

        const videoPlaceholderEl = document.createElement('div')
        this.append(videoPlaceholderEl);

        const paramsObj = Object.fromEntries(this.getParams().entries());

        this.playerPromise = new Promise(resolve => {
            let player = new YT.Player(videoPlaceholderEl, {
                width: '100%',
                videoId: this.videoId,
                playerVars: paramsObj,
                events: {
                    'onReady': event => {
                        event.target.playVideo();
                        resolve(player);
                    }
                }
            });
        });
    }

    // Add the iframe within <noscript> for indexability discoverability. See https://github.com/paulirish/lite-youtube-embed/issues/105
    addNoscriptIframe() {
        const iframeEl = this.createBasicIframe();
        const noscriptEl = document.createElement('noscript');
        // Appending into noscript isn't equivalant for mysterious reasons: https://html.spec.whatwg.org/multipage/scripting.html#the-noscript-element
        noscriptEl.innerHTML = iframeEl.outerHTML;
        this.append(noscriptEl);
    }

    getParams() {
        const params = new URLSearchParams(this.getAttribute('params') || []);
        params.append('autoplay', '1');
        params.append('playsinline', '1');
        return params;
    }

    async activate(){
        if (this.classList.contains('lyt-activated')) return;
        this.classList.add('lyt-activated');

        if (this.needsYTApi) {
            return this.addYTPlayerIframe(this.getParams());
        }

        const iframeEl = this.createBasicIframe();
        this.append(iframeEl);

        // Set focus for a11y
        iframeEl.focus();
    }

    createBasicIframe(){
        const iframeEl = document.createElement('iframe');
        iframeEl.width = 560;
        iframeEl.height = 315;
        // No encoding necessary as [title] is safe. https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html#:~:text=Safe%20HTML%20Attributes%20include
        iframeEl.title = this.playLabel;
        iframeEl.allow = 'accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture';
        iframeEl.allowFullscreen = true;
        // AFAIK, the encoding here isn't necessary for XSS, but we'll do it only because this is a URL
        // https://stackoverflow.com/q/64959723/89484
        iframeEl.src = `https://www.youtube-nocookie.com/embed/${encodeURIComponent(this.videoId)}?${this.getParams().toString()}`;
        return iframeEl;
    }

    /**
     * In the spirit of the `lowsrc` attribute and progressive JPEGs, we'll upgrade the reliable
     * poster image to a higher resolution one, if it's available.
     * Interestingly this sddefault webp is often smaller in filesize, but we will still attempt it second
     * because getting _an_ image in front of the user if our first priority.
     *
     * See https://github.com/paulirish/lite-youtube-embed/blob/master/youtube-thumbnail-urls.md for more details
     */
    upgradePosterImage() {
         // Defer to reduce network contention.
        setTimeout(() => {
            const webpUrl = `https://i.ytimg.com/vi_webp/${this.videoId}/sddefault.webp`;
            const img = new Image();
            img.fetchPriority = 'low'; // low priority to reduce network contention
            img.referrerpolicy = 'origin'; // Not 100% sure it's needed, but https://github.com/ampproject/amphtml/pull/3940
            img.src = webpUrl;
            img.onload = e => {
                // A pretty ugly hack since onerror won't fire on YouTube image 404. This is (probably) due to
                // Youtube's style of returning data even with a 404 status. That data is a 120x90 placeholder image.
                // … per "annoying yt 404 behavior" in the .md
                const noAvailablePoster = e.target.naturalHeight == 90 && e.target.naturalWidth == 120;
                if (noAvailablePoster) return;

                this.style.backgroundImage = `url("${webpUrl}")`;
            }
        }, 100);
    }
}
// Register custom element
customElements.define('lite-youtube', LiteYTEmbed);

			const style = document.head.appendChild(document.createElement('style'));
style.textContent = /*css*/`

  lite-vimeo {
    aspect-ratio: 16 / 9;
    background-color: #000;
    position: relative;
    display: block;
    contain: content;
    background-position: center center;
    background-size: cover;
    cursor: pointer;
  }

  lite-vimeo > iframe {
    width: 100%;
    height: 100%;
    position: absolute;
    top: 0;
    left: 0;
    border: 0;
  }

  lite-vimeo > .ltv-playbtn {
    font-size: 10px;
    padding: 0;
    width: 6.5em;
    height: 4em;
    background: rgba(23, 35, 34, .75);
    z-index: 1;
    opacity: .8;
    border-radius: .5em;
    transition: opacity .2s ease-out, background .2s ease-out;
    outline: 0;
    border: 0;
    cursor: pointer;
  }

  lite-vimeo:hover > .ltv-playbtn {
    background-color: rgb(0, 173, 239);
    opacity: 1;
  }

  /* play button triangle */
  lite-vimeo > .ltv-playbtn::before {
    content: '';
    border-style: solid;
    border-width: 10px 0 10px 20px;
    border-color: transparent transparent transparent #fff;
  }

  lite-vimeo > .ltv-playbtn,
  lite-vimeo > .ltv-playbtn::before {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate3d(-50%, -50%, 0);
  }

  /* Post-click styles */
  lite-vimeo.ltv-activated {
    cursor: unset;
  }

  lite-vimeo.ltv-activated::before,
  lite-vimeo.ltv-activated > .ltv-playbtn {
    opacity: 0;
    pointer-events: none;
  }
`;

/**
 * Ported from https://github.com/paulirish/lite-youtube-embed
 *
 * A lightweight vimeo embed. Still should feel the same to the user, just MUCH faster to initialize and paint.
 *
 * Thx to these as the inspiration
 *   https://storage.googleapis.com/amp-vs-non-amp/youtube-lazy.html
 *   https://autoplay-youtube-player.glitch.me/
 *
 * Once built it, I also found these:
 *   https://github.com/ampproject/amphtml/blob/master/extensions/amp-youtube (👍👍)
 *   https://github.com/Daugilas/lazyYT
 *   https://github.com/vb/lazyframe
 */
class LiteVimeo extends (globalThis.HTMLElement ?? class {}) {
  /**
   * Begin pre-connecting to warm up the iframe load
   * Since the embed's network requests load within its iframe,
   *   preload/prefetch'ing them outside the iframe will only cause double-downloads.
   * So, the best we can do is warm up a few connections to origins that are in the critical path.
   *
   * Maybe `<link rel=preload as=document>` would work, but it's unsupported: http://crbug.com/593267
   * But TBH, I don't think it'll happen soon with Site Isolation and split caches adding serious complexity.
   */
  static _warmConnections() {
    if (LiteVimeo.preconnected) return;
    LiteVimeo.preconnected = true;

    // The iframe document and most of its subresources come right off player.vimeo.com
    addPrefetch('preconnect', 'https://player.vimeo.com');
    // Images
    addPrefetch('preconnect', 'https://i.vimeocdn.com');
    // Files .js, .css
    addPrefetch('preconnect', 'https://f.vimeocdn.com');
    // Metrics
    addPrefetch('preconnect', 'https://fresnel.vimeocdn.com');
  }

  connectedCallback() {
    this.videoId = this.getAttribute('videoid');

    /**
     * Lo, the vimeo placeholder image!  (aka the thumbnail, poster image, etc)
     * We have to use the Vimeo API.
     */
    let { width, height } = getThumbnailDimensions(this.getBoundingClientRect());
    let devicePixelRatio = window.devicePixelRatio || 1;
    if (devicePixelRatio >= 2) devicePixelRatio *= .75;
    width = Math.round(width * devicePixelRatio);
    height = Math.round(height * devicePixelRatio);

    fetch(`https://vimeo.com/api/v2/video/${this.videoId}.json`)
      .then(response => response.json())
      .then(data => {
        let thumbnailUrl = data[0].thumbnail_large;
        thumbnailUrl = thumbnailUrl.replace(/-d_[\dx]+$/i, `-d_${width}x${height}`);
        this.style.backgroundImage = `url("${thumbnailUrl}")`;
      });

    let playBtnEl = this.querySelector('.ltv-playbtn');
    // A label for the button takes priority over a [playlabel] attribute on the custom-element
    this.playLabel = (playBtnEl && playBtnEl.textContent.trim()) || this.getAttribute('playlabel') || 'Play video';

    if (!playBtnEl) {
      playBtnEl = document.createElement('button');
      playBtnEl.type = 'button';
      playBtnEl.setAttribute('aria-label', this.playLabel);
      playBtnEl.classList.add('ltv-playbtn');
      this.append(playBtnEl);
    }
    playBtnEl.removeAttribute('href');

    // On hover (or tap), warm up the TCP connections we're (likely) about to use.
    this.addEventListener('pointerover', LiteVimeo._warmConnections, {
      once: true
    });

    // Once the user clicks, add the real iframe and drop our play button
    // TODO: In the future we could be like amp-youtube and silently swap in the iframe during idle time
    //   We'd want to only do this for in-viewport or near-viewport ones: https://github.com/ampproject/amphtml/pull/5003
    this.addEventListener('click', this.addIframe);
  }

  addIframe() {
    if (this.classList.contains('ltv-activated')) return;
    this.classList.add('ltv-activated');

    const iframeEl = document.createElement('iframe');
    iframeEl.width = 640;
    iframeEl.height = 360;
    // No encoding necessary as [title] is safe. https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html#:~:text=Safe%20HTML%20Attributes%20include
    iframeEl.title = this.playLabel;
    iframeEl.allow = 'accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture';
    // AFAIK, the encoding here isn't necessary for XSS, but we'll do it only because this is a URL
    // https://stackoverflow.com/q/64959723/89484
    iframeEl.src = `https://player.vimeo.com/video/${encodeURIComponent(this.videoId)}?autoplay=1`;
    this.append(iframeEl);

    // Set focus for a11y
    iframeEl.addEventListener('load', iframeEl.focus, { once: true });
  }
}

if (globalThis.customElements && !globalThis.customElements.get('lite-vimeo')) {
  globalThis.customElements.define('lite-vimeo', LiteVimeo);
}

/**
 * Add a <link rel={preload | preconnect} ...> to the head
 */
function addPrefetch(kind, url, as) {
  const linkElem = document.createElement('link');
  linkElem.rel = kind;
  linkElem.href = url;
  if (as) {
    linkElem.as = as;
  }
  linkElem.crossorigin = true;
  document.head.append(linkElem);
}

/**
 * Get the thumbnail dimensions to use for a given player size.
 *
 * @param {Object} options
 * @param {number} options.width The width of the player
 * @param {number} options.height The height of the player
 * @return {Object} The width and height
 */
function getThumbnailDimensions({ width, height }) {
  let roundedWidth = width;
  let roundedHeight = height;

  // If the original width is a multiple of 320 then we should
  // not round up. This is to keep the native image dimensions
  // so that they match up with the actual frames from the video.
  //
  // For example 640x360, 960x540, 1280x720, 1920x1080
  //
  // Round up to nearest 100 px to improve cacheability at the
  // CDN. For example, any width between 601 pixels and 699
  // pixels will render the thumbnail at 700 pixels width.
  if (roundedWidth % 320 !== 0) {
    roundedWidth = Math.ceil(width / 100) * 100;
    roundedHeight = Math.round((roundedWidth / width) * height);
  }

  return {
    width: roundedWidth,
    height: roundedHeight
  };
}
</script>